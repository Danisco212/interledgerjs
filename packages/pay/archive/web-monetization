import { Plugin } from 'ilp-protocol-stream/dist/src/util/plugin-interface'
import EventEmitter from 'eventemitter3'
import { isPaymentError, PaymentError } from '.'
import { AssetDetails, AssetDetailsController } from './controllers/asset-details'
import { queryAccount } from './open-payments'
import {
  ControllerMap,
  StreamController,
  StreamReply,
  NextRequest,
  StreamRequest,
} from './controllers'
import { SequenceController } from './controllers/sequence'
import { FailureController } from './controllers/failure'
import { MaxPacketAmountController } from './controllers/max-packet'
import { PacingController } from './controllers/pacer'
import { PendingRequestTracker } from './controllers/pending-requests'
import { CongestionController } from './controllers/liquidity-congestion'
import { createConnection } from './connection'
import { Int, getConnectionLogger, timeout, PromiseResolver } from './utils'
import {
  StreamMoneyFrame,
  FrameType,
  StreamReceiptFrame,
} from 'ilp-protocol-stream/dist/src/packet'
import { DEFAULT_STREAM_ID } from './controllers/payment'
import { createSendLoop } from './send-loop'
import { ExpiryController } from './controllers/expiry'
import createLogger from 'ilp-logger'
import BigNumber from 'bignumber.js'
import Long from 'long'

/** Event when additional funds delivered after a packet is fulfilled */
export interface MoneyEvent {
  /** TODO */
  amountSent: string
  /** Amount delivered to the recipient payment pointer, in the destination asset and units */
  amountDelivered: string
  /** STREAM receipt attesting the amount delivered to a third-party verifier */
  receipt?: string
}

class SimpleAmountController implements StreamController {
  private amountToSend = Int.ZERO
  private amountSent = Int.ZERO
  private amountInFlight = Int.ZERO

  public progressEmitter = new EventEmitter<{
    progress: [MoneyEvent]
  }>()

  private getAvailableToSend(): Int {
    return this.amountToSend.subtract(this.amountSent).subtract(this.amountInFlight)
  }

  queueAmount(amount: Int) {
    this.amountToSend = this.amountToSend.add(amount)
  }

  nextState(request: NextRequest, controllers: ControllerMap): void {
    const availableToSend = this.getAvailableToSend()
    if (!availableToSend.isPositive()) {
      return
    }

    const sourceAmount = availableToSend
      .orLesser(controllers.get(CongestionController).getRemainingInWindow())
      .orLesser(controllers.get(MaxPacketAmountController).getNextMaxPacketAmount() ?? Int.MAX_U64)

    request
      .setSourceAmount(sourceAmount)
      .setMinDestinationAmount(Int.ZERO) // No rate enforcement
      .enableFulfillment()
      .addFrames(new StreamMoneyFrame(DEFAULT_STREAM_ID, 1))
      .send()
  }

  applyRequest({ sourceAmount, isFulfillable }: StreamRequest) {
    if (!isFulfillable) {
      return
    }

    this.amountInFlight = this.amountInFlight.add(sourceAmount)

    return (reply: StreamReply) => {
      this.amountInFlight = this.amountInFlight.subtract(sourceAmount)

      if (!reply.isFulfill()) {
        return
      }

      this.amountSent = this.amountSent.add(sourceAmount)

      // Since there's no delivery enforcement, no verification of the receipt is possible
      const receipt = reply.frames
        ?.find((frame): frame is StreamReceiptFrame => frame.type === FrameType.StreamReceipt)
        ?.receipt.toString('base64')

      this.progressEmitter.emit('progress', {
        // TODO Include totals here, too? Or just total sent?
        amountSent: sourceAmount.toString(),
        amountDelivered: reply.destinationAmount?.toString() ?? '0',
        receipt,
      })
    }
  }
}

/** TODO Explain */
class ConnectionCloseController implements StreamController {
  private shouldClose = false
  private closeStatus = new PromiseResolver<void>()

  nextState(request: NextRequest) {
    if (this.shouldClose) {
      request.addConnectionClose().send()
      this.closeStatus.resolve() // Safe to apply side effects
    }
  }

  close(): Promise<void> {
    this.shouldClose = true
    return this.closeStatus.promise
  }
}

// TODO Rename this to something else? `PaymentStream`?
export interface MonetizationStream
  extends EventEmitter<{
    progress: [MoneyEvent] // TODO Also include the amount sent here?
  }> {
  /** TODO expalin */
  addAmount(amount: number): void
  /** TODO explain */
  start(): Promise<PaymentError | void>
  /** TODO explain */
  pause(): Promise<PaymentError | void>
  /** Tell the receiver the connection is closed */
  end(): Promise<PaymentError | void>
  /** TODO explain */
  destinationAsset: AssetDetails | undefined
}

// TODO rename this?
export const monetize = async (options: {
  paymentPointer: string
  plugin: Plugin
  // TODO Should this be optional/only used in the "send unlimited" case? Or does should is it okay to default to max u64?
  // initialPacketAmount: number // TODO What type should this be? BigNumber.Value? // Optional, but recommended so an F08 isn't required
  useFarFutureExpiry?: boolean
}): Promise<MonetizationStream> => {
  const { plugin, useFarFutureExpiry } = options

  let log = createLogger('ilp-pay')

  // TODO Can I abstract this into a shared function? Then, no duplicated tests for both `monetize` and `pay`
  const connectResult: PaymentError | void = await timeout(
    10_000,
    plugin.connect().catch((err: Error) => {
      log.error('error connecting plugin:', err)
      return PaymentError.Disconnected
    })
  ).catch(() => {
    log.error('plugin failed to connect: timed out.')
    return PaymentError.Disconnected
  })
  if (isPaymentError(connectResult)) {
    throw connectResult
  }

  const credentialsOrError = await queryAccount(options.paymentPointer)
  if (isPaymentError(credentialsOrError)) {
    throw credentialsOrError
  }
  const { sharedSecret, destinationAddress, destinationAsset } = credentialsOrError

  log = await getConnectionLogger(destinationAddress)

  const controllers: ControllerMap = new Map()
    .set(SequenceController, new SequenceController())
    .set(ExpiryController, new ExpiryController(useFarFutureExpiry))
    .set(ConnectionCloseController, new ConnectionCloseController())
    .set(FailureController, new FailureController())
    .set(MaxPacketAmountController, new MaxPacketAmountController())
    .set(PacingController, new PacingController())
    .set(AssetDetailsController, new AssetDetailsController(destinationAsset))
    .set(CongestionController, new CongestionController()) // TODO
    .set(SimpleAmountController, new SimpleAmountController())
    .set(PendingRequestTracker, new PendingRequestTracker())

  const sendRequest = await createConnection(plugin, sharedSecret)
  const sendLoop = createSendLoop(sendRequest, controllers, destinationAddress, log)

  const { progressEmitter } = controllers.get(SimpleAmountController)

  // Combine the event emitter and send loop into the "monetization stream"
  return Object.assign(progressEmitter, {
    get destinationAsset() {
      return controllers.get(AssetDetailsController).getDestinationAsset()
    },

    // TODO Should this take a number, Long, string, BigNumber, BigInt...!?!?!?
    //      Why make it so complex?
    addAmount(amount: string | number | Long | BigNumber) {
      // TODO Fix this?
      const parsedAmount = Int.from(amount)
      const a = Int.from(Long.UONE)
      if (parsedAmount) {
        controllers.get(SimpleAmountController).sendMore(parsedAmount)
      }
    },

    start() {
      return sendLoop.start()
    },

    pause() {
      return sendLoop.stop()
    },

    async end() {
      await Promise.race([
        sendLoop.start() as Promise<PaymentError>,
        controllers.get(ConnectionCloseController).close(),
      ])

      return sendLoop.stop()
    },
  })
}
