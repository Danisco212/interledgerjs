import { PromiseResolver, Int, sleep } from './utils'
import { PaymentError, isPaymentError } from '.'
import { PendingRequestTracker } from './controllers/pending-requests'
import { ControllerMap, NextRequest, StreamController } from './controllers'
import { Frame, ErrorCode, ConnectionCloseFrame } from 'ilp-protocol-stream/dist/src/packet'
import { IlpAddress } from 'ilp-packet'
import { StreamConnection } from './connection'
import { StreamFulfill, StreamReject } from './request'

export const runSendLoop = async <T>(
  connection: StreamConnection, // TODO Have a set of conrollers on the connection i
  controllers: StreamController[],
  until: Promise<T>
): Promise<T | PaymentError> => {
  const { log, sendRequest } = connection

  let isComplete = false // TODO Not complete yet, still running: rename to `readyToPause` or `shouldPause` or `shouldStop` ?
  const sendLoopError = new PromiseResolver<PaymentError>()

  /** Try to send a request, and recursively try again until the send loop encounters an error or ends. */
  const trySending = (): void => {
    if (isComplete) {
      return
    }

    /** Is this request applied and queued to send? */
    let didApplyRequest = false

    // Builder to construct and send/cancel the STREAM request
    const request: NextRequest = {
      destinationAddress: 'private.example' as IlpAddress,
      expiresAt: new Date(),
      sequence: 0,
      sourceAmount: Int.ZERO,
      minDestinationAmount: Int.ZERO,
      requestFrames: [],
      isFulfillable: false,
      log,

      setDestinationAddress(address: IlpAddress) {
        this.destinationAddress = address
        return this
      },

      setExpiry(expiresAt: Date) {
        this.expiresAt = expiresAt
        return this
      },

      setSequence(sequence: number) {
        this.sequence = sequence
        this.log = this.log.extend(sequence.toString())
        return this
      },

      setSourceAmount(sourceAmount: Int) {
        this.sourceAmount = sourceAmount
        return this
      },

      setMinDestinationAmount(minDestinationAmount: Int) {
        this.minDestinationAmount = minDestinationAmount
        return this
      },

      addFrames(...frames: Frame[]) {
        this.requestFrames.push(...frames)
        return this
      },

      addConnectionClose(error = ErrorCode.NoError) {
        return this.addFrames(new ConnectionCloseFrame(error, ''))
      },

      enableFulfillment() {
        this.isFulfillable = true
        return this
      },

      send() {
        const replyHandlers = controllers.map((c) => c.applyRequest?.(this, controllers))
        didApplyRequest = true
        return new Promise((resolve) => {
          sendRequest(this).then((reply) => {
            replyHandlers.forEach((f) => f && f(reply))
            resolve(reply)
          })
        })
      },
    }

    // Iterate through each controller to construct the next request,
    // send it, and determine the next state of the payment
    for (const c of controllers.values()) {
      const waitOrError = c.nextState?.(request, controllers)

      // If error, end the send loop immediately
      if (isPaymentError(waitOrError)) {
        sendLoopError.resolve(waitOrError)
        return
      }
      // If returned value is a Promise, cancel this request. Wait until it settles before trying to send another
      else if (typeof waitOrError === 'object') {
        waitOrError.finally(trySending)
        return
      }
      // If this request is complete, enqueue another
      // (Check this last in case the controller sent the request but also returned an error)
      else if (didApplyRequest) {
        Promise.resolve().then(trySending)
        return
      }
    }

    // If the request wasn't sent (and there was no error or Promise),
    // try sending another request in 5ms
    sleep(5).finally(trySending)
  }

  trySending()

  const result = await Promise.race([sendLoopError.promise, until])
  isComplete = true

  await Promise.all(controllers.get(PendingRequestTracker).getPendingRequests())
  return result
}
